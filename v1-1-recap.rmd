---
title: "v1.1.0 Recap"
author: "gsm Team"
date: "2022-08-02"
output:
  html_document:
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(gsm)
library(dplyr)
library(gt)
library(ggplot2)
```

```{css,echo=FALSE}
h1, h2, h3{
  color: #c83644;
}

.table{
  width: 100%;
  border: 1;
  margin: 0;
  padding: 0;
}

code{
  color: #22576d;
}

```

# Overview

Quick report highlighting major changes to `{gsm}` for `v1.1.0`

<br>

<br>

------------------------------------------------------------------------

### Support dynamic grouping by `SiteID`, `StudyID`, or `Region`/`CustomGroupID`

[Feature: Support Site/Country/Study level assessments](https://github.com/Gilead-BioStats/gsm/issues/460)

```{r}
dfInputAE <- AE_Map_Raw()
```

Summary of changes:

`*_ Map_Raw()` functions now return `SiteID`, `StudyID`, and `CustomGroupID` if present:

```{r}
dfInputAE %>% 
  slice(1:3) %>% 
  gt::gt()
```

`*_Assess()` functions add a `strGroupCol` for grouping:

```{r}
aeAssessment <- AE_Assess(
  dfInputAE,
  strGroupCol = "CustomGroupID"
)

aeAssessment$dfSummary %>% 
  slice(1:3) %>% 
  gt::gt()
```

`inst/mappings` is updated:

-   Example for AE

```{yaml}
dfInput:
  strIDCol: "SubjectID"
  strSiteCol: "SiteID"
  strStudyCol: "StudyID"
  strCustomGroupCol: "RegionID"
  strCountCol: "Count"
  strExposureCol: "Exposure"
  strRateCol: "Rate"
```

TODO:

1.  If needed, put some guards in place to prevent grouping by too few unique values, i.e. if a study only has two regions.
2.  Avoid specifying column names directly in `\workflow` files - implement something like `strGroupMapping` and specify the mapping parameter such as `strStudyCol`, `strSiteCol`, `strCustomGroupCol`

<br>

------------------------------------------------------------------------

### Workflow updates to support Stratified KRIs, aka add `MakeStratifiedAssessment()`

Initial implementation: [Stratification prototype PR](https://github.com/Gilead-BioStats/gsm/pull/555)

Updated: [Bugfix: MakeStratifiedAssessment() fails when data is not found](https://github.com/Gilead-BioStats/gsm/issues/570)

PD Implementation with workflow and example (see below): [Add workflow that assess PDs by category.](https://github.com/Gilead-BioStats/gsm/pull/606/files)

```{r message=FALSE, warning=FALSE}
lMapping <- yaml::read_yaml(
  system.file("mappings", "mapping_rawplus.yaml", package = "gsm")
)

StratifiedPD <- MakeStratifiedAssessment(
   lData = list(
     dfSUBJ = clindata::rawplus_subj,
     dfPD = clindata::rawplus_pd
   ),
   lMapping = lMapping,
   lAssessment = MakeAssessmentList()$pdCategory
 )

stratifiedPDAssessment <- StratifiedPD %>%
  purrr::map(~.x %>%
    RunAssessment(
      lData = list(
        dfSUBJ = clindata::rawplus_subj,
        dfPD = clindata::rawplus_pd
      ),
      lMapping = lMapping
    )
  )
```

```{r}
stratifiedPDAssessment$pdCategory_1$lResults$dfSummary %>% 
  slice(1:3) %>% 
  gt::gt()
```

TODO:

1.  Possibly not the best implementation to return `NULL` [here](https://github.com/Gilead-BioStats/gsm/blob/dev/R/util-MakeStratifiedAssessment.R#L97-L114)
2.  Spencer's suggestion to move this step upstream when the workflow/assessment is created.

<br>

------------------------------------------------------------------------

### Add Support for nominal vs. statistical Assessments, i.e. add `Analyze_Identity()`

[Fix 463 - support for nominal and statistical assessments](https://github.com/Gilead-BioStats/gsm/pull/574)

```{r}
dfInputConsent <- Consent_Map_Raw()

# Analyze_Identity() run by default
consentAssessment <- Consent_Assess(dfInputConsent)

dfInputAE <- AE_Map_Raw()

# specify strMethod = "identity"
aeAssessment <- AE_Assess(dfInputAE, strMethod = "identity")

aeAssessment$dfSummary %>% 
  slice(1:3) %>% 
  gt::gt()
```

<br>

------------------------------------------------------------------------

### Add Disposition

```{r}
dfInputDispStudy <- Disp_Map_Raw(strContext = "Study")
dfInputDispTreatment <- Disp_Map_Raw(strContext = "Treatment")

dispAssessment <- Disp_Assess(dfInputDispTreatment)
```

```{r}
dispAssessment$dfSummary %>% 
  slice(1:3) %>% 
  gt::gt()
```

```{r}
dispAssessment$chart %>% plotly::ggplotly(tooltip = 'tooltip')
```

TODO:

1.  Update cookbook/document how to run `Disp_Map_Raw()` for study and/or treatment discontinuation. Additionally, document how to specify in workflow.

<br>

------------------------------------------------------------------------

### Capture `dfBounds` when `Analyze_Poisson_PredictBounds()` is run

```{r}
dfInputAE <- AE_Map_Raw()

aeAssessment <- AE_Assess(dfInputAE)

aeAssessment$dfBounds %>% 
  slice(1:10) %>% 
  gt::gt()
```

# In Progress...

### Create default KRI visualization `Visualize_Score()`

[Visualize Score PR](https://github.com/Gilead-BioStats/gsm/pull/620)

```{r}
Visualize_Score <- function(
    dfFlagged,
    strType = "KRI",
    bFlagFilter = FALSE,
    strTitle = ""
    ) {
  stopifnot(
    "strTitle must be character" = is.character(strTitle),
    "bFlagFilter must be logical" = is.logical(bFlagFilter),
    "dfFlagged must be a data.frame" = is.data.frame(dfFlagged),
    "strType must be 'KRI' or 'score'" = strType %in% c("KRI", "score"),
    "strType must be length 1" = length(strType) == 1
  )

  if(bFlagFilter) {
    dfFlagged <- dfFlagged %>%
      filter(
        .data$Flag != 0
        )
  }

  if(strType == "KRI") {

    dfFlaggedWithTooltip <- dfFlagged %>%
      mutate(
        tooltip = paste(
          paste0('Group: ', .data$GroupLabel),
          paste0('GroupID: ', .data$GroupID),
          paste(.data$KRI, .data$KRILabel),
          sep = '\n'
        )
      )

    p <- dfFlaggedWithTooltip %>%
      ggplot(
        aes(
        x = reorder(.data$GroupID, -.data$KRI), y = .data$KRI,
        text = .data$tooltip
        )
      ) +
      geom_bar(
        stat = "identity"
        ) +
      geom_hline(
        yintercept = sum(dfFlagged$TotalCount)/sum(dfFlagged$TotalExposure),
        linetype="dashed",
        color="red",
        size=1
      ) +
      ylab(
        paste0("KRI [", unique(dfFlagged$KRILabel), "]")
        )

  }

  if(strType == "score") {

    ThresholdLow <- unique(dfFlagged$ThresholdLow)
    ThresholdHigh <- unique(dfFlagged$ThresholdHigh)

    dfFlaggedWithTooltip <- dfFlagged %>%
      mutate(
        tooltip = paste(
          paste0('Group: ', .data$GroupLabel),
          paste0('GroupID: ', .data$GroupID),
          paste(.data$ScoreLabel, '=', .data$Score),
          sep = '\n'
        )
      )

    p <- dfFlaggedWithTooltip %>%
      ggplot(
        aes(
          x = reorder(.data$GroupID, -.data$Score), y = .data$Score,
          tooltip = .data$tooltip
          )
        ) +
      geom_bar(
        stat = "identity"
        ) +
      ylab(
        paste0("Score [", unique(dfFlagged$ScoreLabel), "]")
        )

    if(!is.na(ThresholdLow)) {
      p <- p +
        geom_hline(
          yintercept = unique(dfFlagged$ThresholdLow),
          linetype = "dashed",
          color = "red",
          size = 1
        )
    }

    if(!is.na(ThresholdHigh)) {
      p <- p +
        geom_hline(
          yintercept = unique(dfFlagged$ThresholdHigh),
          linetype = "dashed",
          color = "red",
          size = 1
        )
    }
  }

  p <- p +
    xlab(
      unique(dfFlagged$GroupLabel)
      ) +
    theme_bw() +
    theme(
      axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
      panel.grid.major.x = element_blank(),
      legend.position = "none"
    ) +
    ggtitle(strTitle)

  if(nrow(dfFlaggedWithTooltip) > 25) {
    p <- p +
      theme(
        axis.ticks.x = element_blank()
      )
  }

  return(p)

}

plt <- function(p) {
  p %>% 
    plotly::ggplotly(tooltip = 'tooltip')
}
```

```{r}
dfInputPD <- PD_Map_Raw()

pdAssessment <- PD_Assess(dfInputPD)



```

Default (KRI):

```{r}
Visualize_Score(pdAssessment$dfFlagged) %>% plt
```

Flagged sites only (KRI):

```{r}
Visualize_Score(pdAssessment$dfFlagged, bFlagFilter = TRUE) %>% plt
```

Score:

```{r}
Visualize_Score(pdAssessment$dfFlagged, strType = "score") %>% plt
```

Flagged sites only (Score):

```{r}
Visualize_Score(pdAssessment$dfFlagged, strType = "score", bFlagFilter = TRUE) %>% plt
```

### Lab Abnormality

[Link to PR](https://github.com/Gilead-BioStats/gsm/pull/617)
