---
title: "Qualification Report for the {gsm} R Package (v1.5)"
date: "Report Run Date: `r Sys.Date()`"
output: 
  pdf_document:
    toc: true
    number_sections: true
vignette: >
  %\VignetteIndexEntry{Qualification}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown_notangle}
---

```{r setup, echo=FALSE, warning=FALSE}
suppressPackageStartupMessages({
  library(gsm)
  library(knitr)
  library(dplyr)
  library(purrr)
  library(pander)
  library(gh)
  library(stringr)
  library(riskmetric)
})

opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = TRUE,
  echo = FALSE,
  results = "asis",
  message = FALSE,
  tidy = FALSE
)

source(here::here("inst", "qualification", "specs.R"))
source(here::here("inst", "qualification", "test_cases.R"))
spec_df <- import_specs()
```

# Introduction

What is ```gsm```? How does it support RBQM?

Blah blah...

# Test Results: Overview

```{r SummariseResults}
spec_list <- list.files(here::here('tests', 'testqualification', 'qualification'), pattern = ".R")
spec_list <- spec_list[-1]
spec_list <- paste0("~/gsm/tests/testqualification/qualification/", spec_list)

scrape <- map_df(spec_list, function(x) {
    test_case_report <- invisible(testthat::test_file(x, reporter = testthat::SilentReporter)[[1]])
    tibble(name = test_case_report$file, result = test_case_report$results[[1]]$message)
})





testResultsRaw <- testthat::test_file("~/gsm/tests/testqualification/qualification/test_qual_T1_1.R", reporter = testthat::ListReporter)

testResultsIndividual <- testResultsRaw %>%
  as_tibble() %>%
  rename(`Test Name` = test) %>%
  group_by(file, context, `Test Name`) %>%
  summarise(`Number of Tests` = first(nb),
            `Number Passed` = sum(passed),
            `Number Failed` = sum(failed),
            `Number Warnings` = sum(warning),
            `Number Errors` = sum(as.numeric(error)),
            `Number Skipped` = sum(as.numeric(skipped)),
            `User Runtime (sec)` = user,
            `System Runtime (sec)` = system,
            `Real Runtime (sec)` = real,
            .groups = "drop")

testResultsNested <- testResultsIndividual %>%
  nest_by(file, context, .key = "Results") %>%
  nest_by(file, .key = "Categories")

SummariseResults <- function(res) {
  res %>% 
    summarise_if(is.numeric, sum) %>% 
    knitr::kable(align = rep("c",9))
}

SummariseResults(testResultsIndividual)
```

# Test Results: Detailed

Loop through qual_map
Add function description to specs file









# Testing Environment

```{r sessioninfo}
pander::pander(sessionInfo())
pander::pandoc.p('\\pagebreak')
```

# ```gsm``` Imports

This section outlines the ```riskmetric``` scores for all of the R packages which ```gsm``` imports for use within the package.  When interpreting the pkg_score, the scale goes from 1 into the negatives. The farther a number is from 1 the better the score is for the package.

```{r riskmetric, warning = FALSE}
import_risk <- strsplit(devtools::as.package(here::here())$imports, ",\n")[[1]] %>% 
  map_chr(~gsub( " .*$", "", .x )) %>% 
  pkg_ref() %>%
  pkg_assess() %>%
  pkg_score() %>% 
  select("package", "version", "pkg_score")
pander::pandoc.table(import_risk, style = "grid")
```


# Assessments

```{r create_assessment_section}
create_assessment_section <- function(assessment, df){
  pander::pandoc.header(paste0("Assessment ", assessment), level = 2)
  pander::pandoc.header("Specifications", level = 3)
  for (i in 1:nrow(df)){
    pander::pandoc.p(
      c(
        pander::pandoc.p(paste0(df[i, "ID"], ": ", df[i, "Description"])),
        pander::pandoc.indent(paste0("Risk: ", df[i, "Risk"]), 2),
        pander::pandoc.indent(paste0("Impact: ", df[i, "Impact"]), 2),
        pander::pandoc.indent(paste0("Tests: ", df[i, "Tests"]), 2)
        )
      )
  }
  pander::pandoc.header("Traceability Matrix", level = 3)
  pander::pandoc.table(build_traceability_matrix(df), style = "grid")
  pander::pandoc.header("Test Cases", level = 3)
  pander::pandoc.table(run_all_tests(df), style = "grid")
  pander::pandoc.p('\\pagebreak')
}
```

```{r assessments}
assessments <- spec_df %>% 
  pull(Assessment) %>% 
  unique()

for (a in assessments){
  a_df <- filter(spec_df, Assessment == a) %>%
    select(-Assessment)
  create_assessment_section(a, a_df)
}
```

# Unit Tests

```{r covr}
pkg_cov <- covr::coverage_to_list(covr::package_coverage(here::here()))
pandoc.p(paste(paste0(names(pkg_cov[[1]]), " = ", pkg_cov[[1]], "%"), collapse = "\n\n"))
```

# Pull Request Overview

```{r prs}
release <- gh("/repos/Gilead-BioStats/gsm/releases", .token = remotes:::github_pat())[[1]]
release_date <- ifelse(is.null(release$published_at), release$created_at, release$published_at)

pr_at_date <- FALSE
page_num <- 1
prs <- list()
while(pr_at_date != TRUE){
  resp <- gh("/repos/Gilead-BioStats/gsm/pulls", per_page = 100, .token = remotes:::github_pat(),
             .params = list(page = page_num, state = "all"))

  map(resp, function(x){
    if (!is.null(x$closed_at) &
        min(as.character(x$closed_at), as.POSIXct(Sys.time())) < as.character(release_date)){
      pr_at_date <<- TRUE
      }
    })

  if (pr_at_date == TRUE){
    resp_sub <- resp %>%
      keep(~ !is.null(.$closed_at) &
             min(as.character(.$closed_at), as.POSIXct(Sys.time())) < as.character(release_date))
    prs <<- append(prs, resp_sub)

  }else{
    prs <<- append(prs, resp)
  }
  page_num <<- page_num + 1
}

getRepoDetails <- function(x) {

  PullRequest <- x[["number"]]
  Requester <- x[["user"]][["login"]]
  DateRequested <- x[["created_at"]]
  Branch <- x[["head"]][["ref"]]
  Target <- x[["base"]][["ref"]]
  Title <- x[["title"]]
  Link <- x[["html_url"]]

  if (length(x[["requested_reviewers"]]) > 0) {
    Reviewers <- paste(map(x[["requested_reviewers"]], ~ .x[["login"]]), collapse = "\n\n")
  } else {
    Reviewers = ""
  }

  tempReviews <- gh(paste0("GET /repos/Gilead-BioStats/gsm/pulls/", PullRequest, "/reviews"))

  if (length(tempReviews) > 0) {
  ReviewStatus <- tempReviews[[1]][["state"]]
  ReviewComments <- tempReviews[[1]][["body"]]
  } else {
    ReviewStatus <- ""
    ReviewComments <- "None"
  }

  pr <- tibble(
    `Pull Request` = PullRequest,
    Requester = Requester,
    `Date Requested` = gsub("T|Z", " ", DateRequested),
    Branch = Branch,
    Target = Target,
    Title = Title,
    Reviewers = Reviewers,
    `Review Status` = ReviewStatus,
    Link = Link
  ) %>%
    map(~ gsub("[^\u0001-\u007F]+|<U\\+\\w+>","", .x)) %>%
    map(~ gsub("`", " ` ", .x)) %>%
    map(~ str_squish(.x)) %>%
    map(~ trimws(.x))

  return(pr)

}

tbl <- map_df(prs, ~getRepoDetails(.))

for (i in 1:nrow(tbl)){
  pander::pandoc.p(
    c(
      pander::pandoc.header(paste0("Pull Request ", tbl[i, "Pull Request"], ": ", tbl[i, "Title"]), level = 3),
      pander::pandoc.p(paste0("Merging ", tbl[i, "Branch"], " into ", tbl[i, "Target"], "\n")),
      pander::pandoc.p(pander::pandoc.link(tbl[i, "Link"])),
      pander::pandoc.table(tbl[i, c("Requester", "Date Requested",
                                    "Reviewers", "Review Status")],
                           split.cells = 13)
      )
    )
}
```

