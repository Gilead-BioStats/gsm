% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/QueryRate_Map_Raw.R
\name{QueryRate_Map_Raw}
\alias{QueryRate_Map_Raw}
\title{Query Rate - Raw Mapping}
\usage{
QueryRate_Map_Raw(
  dfs = list(dfSUBJ = clindata::rawplus_dm, dfQuery = clindata::edc_queries, dfDataChg =
    clindata::edc_data_change_rate),
  lMapping = yaml::read_yaml(system.file("mappings", "mapping_edc.yaml", package =
    "gsm")),
  bReturnChecks = FALSE,
  bQuiet = TRUE
)
}
\arguments{
\item{dfs}{\code{list} Input data frames:
\itemize{
\item \code{dfSUBJ}: \code{data.frame} Subject-level data with one record per subject.
\item \code{dfQuery}: \code{data.frame} Query-level data with one record per query.
\item \code{dfDataChg}: \code{data.frame} Data-Point-level data with one record per data entry.
}}

\item{lMapping}{\code{list} Column metadata with structure \code{domain$key}, where \code{key} contains the name
of the column.}

\item{bReturnChecks}{\code{logical} Return input checks from \code{\link[=is_mapping_valid]{is_mapping_valid()}}? Default: \code{FALSE}}

\item{bQuiet}{\code{logical} Suppress warning messages? Default: \code{TRUE}}
}
\value{
\code{data.frame} Data frame with one record per subject, the input to \code{\link[=QueryRate_Assess]{QueryRate_Assess()}}. If
\code{bReturnChecks} is \code{TRUE} \code{QueryRate_Map_Raw} returns a named \code{list} with:
\itemize{
\item \code{df}: the data frame described above
\item \code{lChecks}: a named \code{list} of check results
}
}
\description{
Convert raw query data to formatted input data to \code{\link[=QueryRate_Assess]{QueryRate_Assess()}}.
}
\details{
\code{QueryRate_Map_Raw} combines query data with data points data and subject-level data to create
formatted input data to \code{\link[=QueryRate_Assess]{QueryRate_Assess()}}. This function creates an input dataset for the Query Rate Assessment
(\code{\link[=QueryRate_Assess]{QueryRate_Assess()}}) by binding subject-level query counts (derived from \code{dfQuery}) and data point counts
(derived from \code{dfDataChg}) to subject-level data (from \code{dfSUBJ}). Note that the function can generate data summaries for specific types of
queries by passing filtered query data to \code{dfQuery}.
}
\section{Data specification}{
\tabular{lllll}{
   \strong{Domain} \tab \strong{Column Key} \tab \strong{Default Value} \tab \strong{Required?} \tab \strong{Require Unique Values?} \cr
   dfSUBJ \tab strSiteCol \tab siteid \tab TRUE \tab FALSE \cr
   dfSUBJ \tab strIDCol \tab subjid \tab TRUE \tab TRUE \cr
   dfDataChg \tab strIDCol \tab  \tab TRUE \tab FALSE \cr
   dfDataChg \tab strDataPointsCol \tab  \tab TRUE \tab FALSE \cr
   dfDataChg \tab strDataPointsChangeCol \tab  \tab TRUE \tab FALSE \cr
}
}

\examples{
# Run with defaults.
dfInput <- QueryRate_Map_Raw()

# Run with error checking and message log.
dfInput <- QueryRate_Map_Raw(bReturnChecks = TRUE, bQuiet = FALSE)

}
